#!/usr/bin/python -u
from ConfigParser import SafeConfigParser
from ConfigParser import NoOptionError
from ConfigParser import NoSectionError
import os
import re
import sys
import time
import yaml

parser = SafeConfigParser()

default_config = os.path.normpath(os.path.join(
    os.path.dirname(__file__), "..", "ardana_service", 'defaults.cfg'))

config_files = [default_config]
local_config = os.path.normpath(os.path.join(
    os.path.dirname(__file__), '..', 'local.cfg'))

if os.path.exists(local_config):
    config_files.append(local_config)

parser.read(config_files)


def get(section, item, default=None):
    try:
        return parser.get(section, item)
    except (NoOptionError, NoSectionError):
        return default

cmd_name = ''

if len(sys.argv) > 1:
   cmd_name = os.path.basename(sys.argv[1])

# Config processor invocation
if len(sys.argv) > 2 and cmd_name.startswith('python') and \
   'config-processor' in sys.argv[2]:

    if get("testing", "mock_config_processor") == "true":

        for pos, arg in enumerate(sys.argv):
            if arg == '-c':
                cloud_config = sys.argv[pos + 1]

            if arg == '-o':
                out_topdir = sys.argv[pos + 1]

        # Do the minimal amount of work to fake the config processor: create
        # a dir with the proper name into the output dir
        with open(cloud_config, 'r') as f:
            data = yaml.load(f)

        outdir = os.path.join(out_topdir, data['cloud']['name'], '2.0',
            'stage', 'info')
        os.makedirs(outdir)

        print "created ", outdir

    else:
        real_cmd = ' '.join(sys.argv[1:])
        os.system(real_cmd)

elif cmd_name == 'ansible-playbook':

    if get("testing", "mock_ansible", None) == "true":
        replay_speed = float(get("testing", "mock_replay_speed", 0))

        log = os.path.normpath(os.path.join(os.path.dirname(__file__),
            "site.log"))

        with open(log) as f:
            lines = f.readlines()

        last_time = 0
        pattern = re.compile(r'^\$\$(\d+): (.*)')
        for line in lines:
            match = re.search(pattern, line)
            if match:
                next_time = int(match.group(1))
                if last_time > 0 and replay_speed > 0:
                    naptime = (next_time - last_time) / (replay_speed * 1000.0)
                    time.sleep(naptime)
                last_time = next_time

                print match.group(2)
            else:
                print line,

    else:
        real_cmd = ' '.join(sys.argv[1:])
        os.system(real_cmd)

exit_code = int(get("testing", "mock_cmd_exit", 0))
if exit_code != 0:
    sys.exit(exit_code)
