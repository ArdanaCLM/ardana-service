#!/usr/bin/python -u
from ConfigParser import SafeConfigParser
from ConfigParser import NoOptionError
from ConfigParser import NoSectionError
import os
import re
import requests
import subprocess
import sys
import time

# The following logic reads the same config files as the ardana service
parser = SafeConfigParser()

default_config = os.path.normpath(os.path.join(
    os.path.dirname(__file__), "..", "ardana_service", 'defaults.cfg'))

config_files = [default_config]
local_config = os.path.normpath(os.path.join(
    os.path.dirname(__file__), '..', 'local.cfg'))

if os.path.exists(local_config):
    config_files.append(local_config)

parser.read(config_files)


def get(section, item, default=None):
    try:
        return parser.get(section, item)
    except (NoOptionError, NoSectionError):
        return default

HOST=get("flask", "host", "127.0.0.1")
PORT=str(get("flask", "port", "9085"))

cmd_name = ''

if len(sys.argv) > 1:
    cmd_name = os.path.basename(sys.argv[1])

# Config processor invocation
if len(sys.argv) > 2 and cmd_name.startswith('python') and \
   'config-processor' in sys.argv[2]:

    if get("testing", "mock_config_processor") == "true":

        for pos, arg in enumerate(sys.argv):
            if arg == '-c':
                cloud_config = sys.argv[pos + 1]

            if arg == '-o':
                out_topdir = sys.argv[pos + 1]

        # Do the minimal amount of work to fake the config processor: create
        # a dir with the proper name into the output dir
        try:
            import yaml

            with open(cloud_config, 'r') as f:
                data = yaml.load(f)
            cloud_name = data['cloud']['name']

        except ImportError:

            # Use regex parsing if yaml lib not available
            with open(cloud_config, 'r') as f:
                lines = f.readlines()

            pattern = re.compile(r'^\s*name:\s*(\S+)')
            for line in lines:
                match = re.search(pattern, line)
                if match:
                    cloud_name = match.group(1)
                    break

        outdir = os.path.join(out_topdir, cloud_name, '2.0', 'stage', 'info')
        os.makedirs(outdir)

    else:
        try:
            subprocess.check_output(sys.argv[1:], stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print e.output
            sys.exit(e.returncode)

elif cmd_name == 'ansible-playbook':

    if get("testing", "mock_ansible", None) == "true":
        replay_speed = float(get("testing", "mock_replay_speed", 0))

        play_id = os.environ.get('PLAY_ID', 0)

        for arg in sys.argv:
            if arg.endswith(".yml"):
                playbook = os.path.basename(arg)
                break

        log = os.path.normpath(os.path.join(os.path.dirname(__file__),
                               playbook.replace('yml','log')))

        with open(log) as f:
            lines = f.readlines()

        last_time = 0
        pattern = re.compile(r'^\$\$(\w+): (.*)')
        for line in lines:
            match = re.search(pattern, line)
            if match:
                if match.group(1) == "EVENT":
                    (event, name) = match.group(2).split(' ')
                    url = 'http://%s:%s/api/v2/listener/playbook' % (HOST, PORT)
                    payload = {'play_id': play_id,
                               'playbook': name,
                               'event': event}
                    requests.post(url, json=payload)
                else:
                    next_time = int(match.group(1))
                    if last_time > 0 and replay_speed > 0:
                        naptime = (next_time - last_time) / (replay_speed * 1000.0)
                        time.sleep(naptime)
                    last_time = next_time

                    print match.group(2)

                    # For debugging crosstalk between events and logs, it
                    # can be useful to prefix the log entry with the
                    # playbook name
                    # print playbook, match.group(2)
            else:
                print line,
                # print playbook, line, # (See above comment)

    else:
        try:
            subprocess.check_output(sys.argv[1:], stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print e.output
            sys.exit(e.returncode)

exit_code = int(get("testing", "mock_cmd_exit", 0))
if exit_code != 0:
    sys.exit(exit_code)
